# A0138601M
###### /java/seedu/todolist/logic/commands/AddCommand.java
``` java
    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            
            indicateJumpToListRequestedEvent();
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
    }
    
    private void indicateJumpToListRequestedEvent() {
        int indexToJump;
        if (model.getCurrentTab().equals(MainWindow.TAB_TASK_INCOMPLETE)) {
            indexToJump = model.getIndexFromIncompleteList(toAdd);
        } else if (model.getCurrentTab().equals(MainWindow.TAB_TASK_OVERDUE)) {
            indexToJump = model.getIndexFromOverdueList(toAdd);
        } else {
            indexToJump = NOT_FOUND;
        }
        EventsCenter.getInstance().post(new JumpToListRequestEvent(indexToJump));
    }

}
```
###### /java/seedu/todolist/logic/commands/DeleteCommand.java
``` java
    private int[] targetIndexes;

    public DeleteCommand(int[] targetIndexes) {
        this.targetIndexes = targetIndexes;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = getLastShownList();       
        if (!isValidIndexes(lastShownList, targetIndexes)) {
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }   
        
        ReadOnlyTask[] tasksToDelete = getAllTaskToDelete(lastShownList);        
        try {
            model.deleteTask(tasksToDelete);
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task cannot be missing";
        }
        
        return new CommandResult(MESSAGE_DELETE_TASK_SUCCESS);
    }
    
    /**
     * Get the last shown listing from the selected tab
     */
    private UnmodifiableObservableList<ReadOnlyTask> getLastShownList() {
        if (model.getCurrentTab().equals(MainWindow.TAB_TASK_COMPLETE)) {
            return model.getFilteredCompleteTaskList();
        } else if (model.getCurrentTab().equals(MainWindow.TAB_TASK_INCOMPLETE)) {
            return model.getFilteredIncompleteTaskList();
        } else if (model.getCurrentTab().equals(MainWindow.TAB_TASK_OVERDUE)) {
            return model.getFilteredOverdueTaskList();
        } else {
            assert false : "Last shown list must come from either completed, incomplete or overdue pane";
            return null;
        }
    }
    
    /**
     * Returns an array of ReadOnlyTask selected using the indexes in the last shown list
     */
    private ReadOnlyTask[] getAllTaskToDelete(UnmodifiableObservableList<ReadOnlyTask> lastShownList) {
        ReadOnlyTask[] tasksToDelete = new ReadOnlyTask[targetIndexes.length];
        for (int i = 0; i < targetIndexes.length; i++) {
            tasksToDelete[i] = lastShownList.get(targetIndexes[i] - MULTIPLE_DELETE_OFFSET);         
        }
        return tasksToDelete;
    }
```
###### /java/seedu/todolist/logic/commands/DoneCommand.java
``` java
/**
 * Marks a task identified using it's last displayed index from the to do list.
 */
public class DoneCommand extends Command {
    public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task identified using it's last displayed index from the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1 \n";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Task marked!";
    public static final String MESSAGE_MARK_COMPLETED_TASK = "This task is already completed!";
    
    public static final int MULTIPLE_MARK_OFFSET = 1;

    private int[] targetIndexes;

    public DoneCommand(int[] targetIndexes) {
        this.targetIndexes = targetIndexes;
    }


    @Override
    public CommandResult execute() {
        if (model.getCurrentTab().equals(MainWindow.TAB_TASK_COMPLETE)) {
            return new CommandResult(MESSAGE_MARK_COMPLETED_TASK);
        }
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = getLastShownList();
        if (!isValidIndexes(lastShownList, targetIndexes)) {
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        ReadOnlyTask[] tasksToMark = getAllTaskToMark(lastShownList);              
        try {
            model.markTask(tasksToMark);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(MESSAGE_MARK_TASK_SUCCESS);
    }
    
    /**
     * Get the last shown listing from the selected tab
     */
    private UnmodifiableObservableList<ReadOnlyTask> getLastShownList() {
        if (model.getCurrentTab().equals(MainWindow.TAB_TASK_INCOMPLETE)) {
            return model.getFilteredIncompleteTaskList();
        } else if (model.getCurrentTab().equals(MainWindow.TAB_TASK_OVERDUE)) {
            return model.getFilteredOverdueTaskList();
        } else {
            assert false : "Last shown list must come from either incomplete or overdue pane";
            return null;
        }
    }
    
    /**
     * Returns an array of ReadOnlyTask selected using the indexes in the last shown list
     */
    private ReadOnlyTask[] getAllTaskToMark(UnmodifiableObservableList<ReadOnlyTask> lastShownList) {
        ReadOnlyTask[] tasksToMark = new ReadOnlyTask[targetIndexes.length];
        for (int i = 0; i < targetIndexes.length; i++) {
            tasksToMark[i] = lastShownList.get(targetIndexes[i] - MULTIPLE_MARK_OFFSET);         
        }
        return tasksToMark;
    }
```
###### /java/seedu/todolist/logic/LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getFilteredCompleteTaskList() {
        return model.getFilteredCompleteTaskList();
    }
    
    @Override
    public ObservableList<ReadOnlyTask> getFilteredIncompleteTaskList() {
        return model.getFilteredIncompleteTaskList();
    }
    
    @Override
    public ObservableList<ReadOnlyTask> getFilteredOverdueTaskList() {
        return model.getFilteredOverdueTaskList();
    }
    
    @Override
    public void setCurrentTab(String tab) {
        model.setCurrentTab(tab);
    }
    
    @Override
    public String getCurrentTab() {
        return model.getCurrentTab();
    }
}
```
###### /java/seedu/todolist/logic/parser/CommandParser.java
``` java
    /**
     * Extracts the new task's start date and time, and end date and time from the add command's interval arguments string.
     * @return a string array that contains start date, start time, end date and end time.
     */
    private String[] parseInterval(String interval) {
        String[] detailedIntervalComponents = new String[DETAILED_INTERVAL_COMPONENT_COUNT];
        if (!Strings.isNullOrEmpty(interval)) {
            detailedIntervalComponents = parseTimedInterval(interval);
        }
        return detailedIntervalComponents;
    }
    
    /**
     * Parses the interval that has date and time
     * @return a string array that contains start date, start time, end date and end time.
     */
    private String[] parseTimedInterval(String interval) {
        if (interval.contains(INTERVAL_SEPARATOR)) {
            return parseEventInterval(interval);
        } else {
            return parseDeadlineInterval(interval);
        }
    }
    
    /**
     * Parses the interval for event type task
     * @return a string array that contains start date, start time, end date and end time.
     */
    private String[] parseEventInterval(String interval) {
        String[] intervalComponents = parseDatetime(interval);
        return new String[] {
                intervalComponents[DETAILED_INTERVAL_INDEX_STARTDATE], 
                intervalComponents[DETAILED_INTERVAL_INDEX_STARTTIME], 
                intervalComponents[DETAILED_INTERVAL_INDEX_ENDDATE], 
                intervalComponents[DETAILED_INTERVAL_INDEX_ENDTIME]};
    }
    
    /**
     * Parses the interval for deadline type task
     * @return a string array that contains start date, start time, end date and end time.
     */
    private String[] parseDeadlineInterval(String interval) {
        String[] endDateTime = parseDatetime(interval);
        return new String[] {
                null, 
                null, 
                endDateTime[DATETIME_INDEX_DATE], 
                endDateTime[DATETIME_INDEX_TIME]};
    }

    /**
     * Extracts the new task's date and time from the add command's datetime arguments string using Natty.
     * @return a string array that contains date and time
     */
    private String[] parseDatetime(String datetime) {
    	String editedDatetime = datetime;
        if (isSlashFormat(datetime)) {
        	editedDatetime = reverseDayAndMonth(datetime);
        }
        
        ArrayList<String> intervalComponents = new ArrayList<String>();
        Parser nattyParser = new Parser();
        DateGroup group = nattyParser.parse(editedDatetime).get(NATTY_INDEX_FIRST);
        Calendar currentDateTime = Calendar.getInstance(); //Get current datetime to compare with natty datetime
        for (Date date : group.getDates()) {
            intervalComponents.add(parseDate(date));
            intervalComponents.add(parseTime(date, currentDateTime));
            
        }       
        return intervalComponents.toArray(new String[intervalComponents.size()]);
    }
    
    /**
     * Returns true if a date is in slash format (i.e. 10/12/2016)
     */
    private boolean isSlashFormat(String datetime) {
        Matcher matcher = Pattern.compile(TaskDate.DATE_VALIDATION_SLASH_REGEX).matcher(datetime.trim());
        return matcher.matches();
    }
    
    /**
     * Reverse day and month for natty parsing
     */
    private String reverseDayAndMonth(String datetime) {
        String[] dateAndTime = datetime.trim().split(DateParser.DATE_DELIMITER_SLASH);
        
        StringBuilder builder = new StringBuilder();
        builder.append(dateAndTime[INDEX_MONTH]);
        builder.append(DateParser.DATE_DELIMITER_SLASH);
        builder.append(dateAndTime[INDEX_DAY]);
        builder.append(DateParser.DATE_DELIMITER_SLASH);
        builder.append(dateAndTime[INDEX_REMAINDER]);

        return builder.toString();
    }
    
    /**
     * Extracts the date from Natty's dategroup
     */
    private String parseDate(Date date) {
        DateFormat dateFormat = new SimpleDateFormat(TaskDate.DATE_DISPLAY_FORMAT);
        return dateFormat.format(date);
    }
    
    /**
     * Extracts the time from Natty's dategroup
     */
    private String parseTime(Date date, Calendar currentDateTime) {
        DateFormat timeFormat = new SimpleDateFormat(TaskTime.TIME_DISPLAY_FORMAT);
        String parsedTime = timeFormat.format(date);
        //ignore if it is a time generated by natty
        if (timeFormat.format(currentDateTime.getTime()).equals(parsedTime)) {
            parsedTime = null;
        }
        return parsedTime;
    }

    /**
     * Parses arguments in the context of the done task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDone(String args) {
        int[] indexes;
        try {
            indexes = parseIndex(args);
        }
        catch (IllegalValueException ive) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_TASK_DISPLAYED_INDEX, DoneCommand.MESSAGE_USAGE));
        }
        return new DoneCommand(indexes);
    }

```
###### /java/seedu/todolist/logic/parser/CommandParser.java
``` java
    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {
        int[] indexes;
        try {
            indexes = parseIndex(args);
        }
        catch (IllegalValueException ive) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }
        return new DeleteCommand(indexes);
    }
    
    /**
     * Extract the indexes from a string of command
     * 
     * @throws IllegalValueException if indexes are invalid
     * @return an int array if valid indexes are provided.
     */
    private int[] parseIndex(String command) throws IllegalValueException {
        assert command != null;
        int[] indexes = new int[DEFAULT_INDICES_SIZE];
        
        if (command.trim().contains(INDEX_DELIMITER)) {
            indexes =  parseIndexSeparatedByComma(command);
        } else {
            if (!StringUtil.isUnsignedInteger(command.trim())) {
                throw new IllegalValueException(MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            indexes[DEFAULT_FIRST_INDEX] = Integer.parseInt(command.trim());
        }
        Arrays.sort(indexes);
        return indexes;
    }

    /**
     * Extract the indexes from a string of command
     * 
     * @param command is guaranteed to contain commas
     * @throws IllegalValueException if indexes are invalid
     * @return an int array if valid indexes are provided.
     */
    private int[] parseIndexSeparatedByComma(String command) throws IllegalValueException {
        String Trimmedcommand = command.trim();

        String[] indexesString = Trimmedcommand.split(INDEX_DELIMITER);
        int[] indexes = new int[indexesString.length];
        for (int i = 0; i < indexesString.length; i++) {
            if (!StringUtil.isUnsignedInteger(indexesString[i].trim())) {
                throw new IllegalValueException(MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            indexes[i] = Integer.parseInt(indexesString[i].trim());
        }
        return indexes;
    }

```
###### /java/seedu/todolist/model/parser/DateParser.java
``` java
/**
 * Converts a String to Date and vice versa.
 */
public class DateParser {
     
    private static final int DATE_COMPONENT_INDEX_YEAR = 2;
    private static final int DATE_COMPONENT_INDEX_MONTH = 1;
    private static final int DATE_COMPONENT_INDEX_DAY = 0;
    
    private static final String MONTH_NOT_FOUND = "Unable to find month ";
    private static final String[] MONTH_LIST = {"JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE", "JULY", 
                                                "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER"};
    private static final int MONTH_DUMMY_VALUE = 0;
    private static final int MONTH_OFFSET_INDEX = 1;
       
    public static final String DATE_DELIMITER_SLASH = "/";
    public static final String DATE_DELIMITER_SPACE = " ";
    
    
    /**
     * Parses string date input into LocalDate date.
     *
     * @param string date input
     * @return LocalDate date based on the string date input
     */
    public static LocalDate parseDate(String date) throws DateTimeException {
        assert date != null;
        LocalDate parsedDate;
        if (date.contains(DATE_DELIMITER_SLASH)) {
            parsedDate = parseDateWithSlash(date);
        } else {
            parsedDate = parseDateWithMonthName(date);
        }
        return parsedDate;
    }
    
    /**
     * Parses string date input with slash into LocalDate date.
     *
     * @param string date input with slash
     * @return LocalDate date based on the string date input
     */
    private static LocalDate parseDateWithSlash(String date) throws DateTimeException {
        String[] dateComponents = date.split(DATE_DELIMITER_SLASH);
        
        int day, month, year;
        day = Integer.parseInt(dateComponents[DATE_COMPONENT_INDEX_DAY]);
        month = Integer.parseInt(dateComponents[DATE_COMPONENT_INDEX_MONTH]);  
        year = Integer.parseInt(dateComponents[DATE_COMPONENT_INDEX_YEAR]);
              
        return LocalDate.of(year, month, day);
    }
    
    /**
     * Parses string date input with month name into LocalDate date.
     *
     * @param string date input with month name
     * @return LocalDate date based on the string date input
     */
    private static LocalDate parseDateWithMonthName(String date) throws DateTimeException {
        String[] dateComponents = date.split(DATE_DELIMITER_SPACE);
        
        int day, month, year;
        day = Integer.parseInt(dateComponents[DATE_COMPONENT_INDEX_DAY]);
        month = getMonthValue(dateComponents[DATE_COMPONENT_INDEX_MONTH]);
        year = Integer.parseInt(dateComponents[DATE_COMPONENT_INDEX_YEAR]);
        
        return LocalDate.of(year, month, day);
    }
    
    /**
     * Parses string month name into int month value.
     *
     * @param string month name
     * @return int month value based on string month name
     */
    private static int getMonthValue(String month) {
        int monthValue = MONTH_DUMMY_VALUE;
        for (int i = 0; i < MONTH_LIST.length; i++) {
            if (MONTH_LIST[i].contains(month.toUpperCase())) {
                monthValue = i + MONTH_OFFSET_INDEX;
            }
        }
        if (monthValue == MONTH_DUMMY_VALUE) {
            throw new DateTimeException(MONTH_NOT_FOUND + month);
        }
        return monthValue;
    }  
}
```
###### /java/seedu/todolist/model/parser/TimeParser.java
``` java
/**
 * Converts a String to Time and vice versa.
 */
public class TimeParser {
    
    private static final int TIME_COMPONENT_TOTAL = 2;
    private static final int TIME_COMPONENT_INDEX_MINUTE = 1;
    private static final int TIME_COMPONENT_INDEX_HOUR = 0;  
    private static final int TIME_COMPONENT_HOUR_START_INDEX = 0; //Position of the start of hour in a string
    private static final int TIME_COMPONENT_PERIOD_LENGTH = 2; //am and pm are 2 characters long
    private static final int TIME_COMPONENT_MINUTE_DEFAULT = 0;   
    private static final int TIME_COMPONENT_PERIOD_OFFSET = 12;
    
    private static final String TIME_DELIMITER = ":";
    
    /**
     * Parses string time input into LocalTime time.
     *
     * @param string time input
     * @return LocalTime time based on the string time input
     */
    public static LocalTime parseTime(String time) throws DateTimeException {
        assert time != null;
        LocalTime parsedTime;

        //trim all spaces away
        String trimmedTime = time.replaceAll("\\s+", "");
        
        if (trimmedTime.toUpperCase().contains("AM")) {
            parsedTime = parseTimeWithAMFormat(trimmedTime);
        } else if (time.toUpperCase().contains("PM")) {
            parsedTime = parseTimeWithPMFormat(trimmedTime);
        } else {
            parsedTime = parseTimeWithContinentalFormat(trimmedTime);
        }
        
        return parsedTime;
    }
    
    /**
     * Parses string time input with AM format into LocalTime time.
     *
     * @param string time input with AM format
     * @return LocalTime time based on the string time input
     */
    private static LocalTime parseTimeWithAMFormat(String time) throws DateTimeException {
        String timeWithoutPeriod = removePeriod(time);
        String[] timeComponents = timeWithoutPeriod.split(":");
        
        int hour, minute;
        if (timeComponents.length < TIME_COMPONENT_TOTAL) {
            hour = Integer.parseInt(timeWithoutPeriod);
            minute = TIME_COMPONENT_MINUTE_DEFAULT;
        } else {
            hour = Integer.parseInt(timeComponents[TIME_COMPONENT_INDEX_HOUR]);
            minute = Integer.parseInt(timeComponents[TIME_COMPONENT_INDEX_MINUTE]);  
        }
           
        if (hour == TIME_COMPONENT_PERIOD_OFFSET) {
            hour = hour - TIME_COMPONENT_PERIOD_OFFSET;
        }
        
        return LocalTime.of(hour, minute);
    }
    
    /**
     * Parses string time input with PM format into LocalTime time.
     *
     * @param string time input with PM format
     * @return LocalTime time based on the string time input
     */
    private static LocalTime parseTimeWithPMFormat(String time) throws DateTimeException {
        String timeWithoutPeriod = removePeriod(time);
        String[] timeComponents = timeWithoutPeriod.split(TIME_DELIMITER);
        
        int hour, minute;
        if (timeComponents.length < TIME_COMPONENT_TOTAL) {
            hour = Integer.parseInt(timeWithoutPeriod);
            minute = TIME_COMPONENT_MINUTE_DEFAULT;
        } else {
            hour = Integer.parseInt(timeComponents[TIME_COMPONENT_INDEX_HOUR]);
            minute = Integer.parseInt(timeComponents[TIME_COMPONENT_INDEX_MINUTE]);  
        }
        
        if (hour != TIME_COMPONENT_PERIOD_OFFSET) {
            hour = hour + TIME_COMPONENT_PERIOD_OFFSET;
        }
        return LocalTime.of(hour, minute);
    }
    
    private static String removePeriod(String time) {
        return time.substring(TIME_COMPONENT_HOUR_START_INDEX, time.length() - TIME_COMPONENT_PERIOD_LENGTH);
    }
    
    /**
     * Parses string time input with continental (24hr) format into LocalTime time.
     *
     * @param string time input with 24hr format
     * @return LocalTime time based on the string time input
     */
    private static LocalTime parseTimeWithContinentalFormat(String time) throws DateTimeException {
        String[] timeComponents = time.split(":");

        int hour = Integer.parseInt(timeComponents[TIME_COMPONENT_INDEX_HOUR]);
        int minute = Integer.parseInt(timeComponents[TIME_COMPONENT_INDEX_MINUTE]); 
        
        return LocalTime.of(hour, minute);
    }
    
}
```
###### /java/seedu/todolist/model/task/Interval.java
``` java
public class Interval implements Comparable<Interval> {
    
    public static final String MESSAGE_INTERVAL_CONSTRAINTS_DATE = "End date cannot be earlier than start date";
    public static final String MESSAGE_INTERVAL_CONSTRAINTS_TIME = "End time cannot be earlier than start time";
    
    private TaskDate startDate;
    private TaskTime startTime;
    private TaskDate endDate;
    private TaskTime endTime;

    
    public Interval() {
        
    }
    
    /**
     * Constructs and validates the Interval based on which parameters given is not null.
     * 
     * Constructs an event type interval if all parameters are not null.
     * Constructs an deadline with time type interval if only endDate and endTime are not null.
     * Constructs an deadline without time type interval if only endDate is not null.
     * Constructs an float type interval if all parameters are null. 
     *
     * @throws IllegalValueException if given date or time is invalid or set of date and time is an invalid interval.
     */
    public Interval(String startDate, String startTime, String endDate, String endTime) throws IllegalValueException {       
        if (isEvent(startDate, startTime, endDate, endTime)) {
            initEvent(startDate, startTime, endDate, endTime);
        } else if (isDeadlineWithTime(startDate, startTime, endDate, endTime)) {
            initDeadlineWithTime(endDate, endTime);
        } else if (isDeadlineWithoutTime(startDate, startTime, endDate, endTime)) {
            initDeadlineWithoutTime(endDate);
        } else if (isFloat(startDate, startTime, endDate, endTime)) {
            initFloat();
        } else {
            assert false : "A given interval must represent an event, deadline, or float";
        }     
    }
    
    /**
     * Initialises an event type interval.
     * 
     * @throws IllegalValueException if given date or time is invalid or set of date and time is an invalid event interval. 
     * For example, endDate earlier than startDate or endTime earlier than startTime.
     */
    private void initEvent(String startDate, String startTime, String endDate, String endTime) throws IllegalValueException {
        this.startDate = new TaskDate(startDate);
        this.startTime = new TaskTime(startTime);
        this.endDate = new TaskDate(endDate);
        this.endTime = new TaskTime(endTime);
        
        if (!isValidDateInterval(this.startDate, this.endDate)) {
            throw new IllegalValueException(MESSAGE_INTERVAL_CONSTRAINTS_DATE);
        }

        if (!isValidTimeInterval(this.startDate, this.startTime, this.endDate, this.endTime)) {
            throw new IllegalValueException(MESSAGE_INTERVAL_CONSTRAINTS_TIME);
        }
    }
    
    /**
     * Initialises a deadline with time type interval.
     * 
     * @throws IllegalValueException if given date or time is invalid
     */
    private void initDeadlineWithTime(String endDate, String endTime) throws IllegalValueException {
        this.endDate = new TaskDate(endDate);
        this.endTime = new TaskTime(endTime);
    }
    
    /**
     * Initialises a deadline without time type interval.
     * 
     * @throws IllegalValueException if given date is invalid
     */
    private void initDeadlineWithoutTime(String endDate) throws IllegalValueException {
        this.endDate = new TaskDate(endDate);
    }
    
    /**
     * Initialises a float type interval.
     */
    private void initFloat() {
        this.startDate = null;
        this.startTime = null;
        this.endDate = null;
        this.endTime = null;
    }

    /**
     * Returns true if a given interval has a valid task date interval. (i.e. startDate is earlier than endDate)
     */
    private boolean isValidDateInterval(TaskDate startDate, TaskDate endDate) {
        return !endDate.isBefore(startDate);
    }
    
    /**
     * Returns true if a given interval has a valid task time interval. 
     * if startDate and endDate are not equal, it is assume to be a valid interval. (i.e. startDate is earlier than endDate)
     */
    private boolean isValidTimeInterval(TaskDate startDate, TaskTime startTime, TaskDate endDate, TaskTime endTime) {
        return !startDate.equals(endDate) || !endTime.isBefore(startTime);
    }
    
    /**
     * Returns true if interval is earlier than current datetime
     */
    public boolean isOver() {
        Interval now = new Interval();
        now.endDate = TaskDate.now();
        now.endTime = TaskTime.now();
        return this.compareTo(now) < 0;
    }
    
    /**
     * Returns true if a given set of datetime is an event.
     */
    private boolean isEvent(String startDate, String startTime, String endDate, String endTime) {
        return startDate != null 
                && startTime != null 
                && endDate != null 
                && endTime != null;
    }
    
    /**
     * Returns true if the interval object is an event.
     */
    public boolean isEvent() {
        return this.startDate != null 
                && this.startTime != null 
                && this.endDate != null 
                && this.endTime != null;
    } 
    
    /**
     * Returns true if a given set of datetime is a deadline with time.
     */
    private boolean isDeadlineWithTime(String startDate, String startTime, String endDate, String endTime) {
        return startDate == null 
                && startTime == null 
                && endDate != null 
                && endTime != null;
    }
    
    /**
     * Returns true if the interval object is a deadline with time.
     */
    public boolean isDeadlineWithTime() {
        return this.startDate == null 
                && this.startTime == null 
                && this.endDate != null 
                && this.endTime != null;
    } 
    
    /**
     * Returns true if a given set of datetime is a deadline without time.
     */
    private boolean isDeadlineWithoutTime(String startDate, String startTime, String endDate, String endTime) {
        return startDate == null 
                && startTime == null
                && endDate != null 
                && endTime == null;
    }
    
    /**
     * Returns true if the interval object is a deadline without time.
     */
    public boolean isDeadlineWithoutTime() {
        return this.startDate == null 
                && this.startTime == null 
                && this.endDate != null 
                && this.endTime == null;
    }
    
    /**
     * Returns true if a given interval is a floating task
     */
    private boolean isFloat(String startDate, String startTime, String endDate, String endTime) {
        return startDate == null 
                && startTime == null 
                && endDate == null 
                && endTime == null;
    }  
    
    /**
     * Returns true if the interval object is a floating task
     */
    public boolean isFloat() {
        return this.startDate == null 
                && this.startTime == null 
                && this.endDate == null 
                && this.endTime == null;
    }
    
    public TaskDate getStartDate() {
        return this.startDate;
    }
    
    public TaskTime getStartTime() {
        return this.startTime;
    }
    
    public TaskDate getEndDate() {
        return this.endDate;
    }
    
    public TaskTime getEndTime() {
        return this.endTime;
    }
    
    /**
     * Returns a formatted string based on the interval type.
     * 
     * Examples:
     * Event type - 20 Nov 2016, 3:00PM to 21 Nov 2016, 4:00PM
     * Deadline with time type - 20 Nov 2016, 3:00PM
     * Deadline without time type - 20 Nov 2016
     */
    public String toString() {
        if (this.isEvent()) {
            return formatStartDateTime() + " to " + formatEndDateTime();
        } else if (this.isDeadlineWithTime()) {
            return formatEndDateTime();
        } else if (this.isDeadlineWithoutTime()) {
            return formatEndDate();
        } else {
            return null;    
        }
    }
    
    public String formatStartDateTime() {
        return startDate + ", " + startTime;
    }
    
    public String formatEndDateTime() {
        return endDate + ", " + endTime;
    }
    
    public String formatEndDate() {
        return endDate + "";
    }
    
    @Override
    public int compareTo(Interval interval) {
        TaskDate firstDate = this.getDateToCompare();
        TaskDate secondDate = interval.getDateToCompare();
        TaskTime firstTime = this.getTimeToCompare();
        TaskTime secondTime = interval.getTimeToCompare();
        
        //If both are float task, they are equal
        if (isFloatTask(firstDate) && isFloatTask(secondDate)) {
            return 0;
        }
        
        return compareDateTime(firstDate, secondDate, firstTime, secondTime);
    }
    
    /**
     * Returns true if TaskDate is null
     */
    private boolean isFloatTask(TaskDate date) {
        return date == null;
    }
    
    /**
     * Returns true is TaskTime is not null
     */
    private boolean isTimedTask(TaskTime time) {
        return time != null;
    }
    
    /**
     * Compares the 2 date-times and determines the ordering
     * firstDate and secondDate cannot both be Float Tasks
     */
    private int compareDateTime(TaskDate firstDate, TaskDate secondDate, TaskTime firstTime, TaskTime secondTime) {
        assert !isFloatTask(firstDate) || !isFloatTask(secondDate);
        
        int compare;
        if (!isFloatTask(firstDate)) {
            compare = compareSecondDate(firstDate, secondDate, firstTime, secondTime);
        } else {
            compare = 1;
        }
        return compare;
    }
    
    /**
     * Compare the secondDate. firstDate must not be null
     * Returns 1 if first date-time is later than second date-time
     * Returns 0 if both date-times are equal
     * Returns -1 otherwise
     */
    private int compareSecondDate(TaskDate firstDate, TaskDate secondDate, TaskTime firstTime, TaskTime secondTime) {
        assert firstDate != null;
        
        if (isFloatTask(secondDate)) {
            return -1;
        } else {
            if (firstDate.equals(secondDate)) { //if date are the same, determine order with time
                return compareTime(firstTime, secondTime);
            }
            return firstDate.compareTo(secondDate);
        }
    }
    
    /**
     * Compares the firstTime and secondTime
     * Returns 1 if first time is later than second time
     * Returns 0 if both times are equal
     * Returns -1 otherwise
     */
    private int compareTime(TaskTime firstTime, TaskTime secondTime) {
        if (isTimedTask(firstTime)) {
            return firstTime.compareTo(secondTime);
        } else if (isTimedTask(secondTime)) {
            return -secondTime.compareTo(firstTime); //flip comparison
        } else {
            return 0;
        }
    }
    
    /**
     * Returns the date to be used for comparison.
     */
    private TaskDate getDateToCompare() {
        if (this.startDate != null) {
            return this.startDate;
        } else if (this.endDate != null) {
            return this.endDate;
        } else {
            return null;
        }
    }
    
    /**
     * Returns the time to be used for comparison.
     */
    private TaskTime getTimeToCompare() {
        if (this.startTime != null) {
            return this.startTime;
        } else if (this.endTime != null) {
            return this.endTime;
        } else {
            return null;
        }
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Interval // instanceof handles nulls
                && TaskDate.isEquals(this.startDate, ((Interval) other).startDate)
                && TaskTime.isEquals(this.startTime, ((Interval) other).startTime)
                && TaskDate.isEquals(this.endDate, ((Interval) other).endDate)
                && TaskTime.isEquals(this.endTime, ((Interval) other).endTime));
    }

}
```
###### /java/seedu/todolist/model/task/Status.java
``` java
/**
 * Represents a Task's status in the to do list.
 * Guarantees: is one of the three values 'complete', 'incomplete' or 'overdue'
 */
public class Status {
    public enum Type {
        Incomplete("incomplete"),
        Complete("complete"),
        Overdue("overdue");
        
        String statusType;
        Type(String type) {
            statusType = type;
        }
        
        @Override
        public String toString() {
            return statusType;
        }
    }

    private Type status;

    /**
     * Constructs a Status object with the default status of type incomplete
     */
    public Status() {
        setStatus(Status.Type.Incomplete);
    }
    
    /**
     * Constructs a Status object with the specified status type
     */
    public Status(Type status) {
        setStatus(status);
    }
    
    /**
    * Constructs a Status object with the specified string name of the type
    */
    public Status(String status) {
        assert status != null;
        
        if (status.equals(Type.Incomplete.toString())) {
            setStatus(Type.Incomplete);
        } else if (status.equals(Type.Complete.toString())) {
            setStatus(Type.Complete);
        } else if (status.equals(Type.Overdue.toString())) {
            setStatus(Type.Overdue);
        } else {
            assert false : "Status must be either incomeplete, complete or overdue";
        }
    }
    
    public Type getType() {
        return this.status;
    }
    
    public void setStatus(Type status) {
        this.status = status;
    }
    
    /**
     * Returns true if the status is incomplete
     */
    public boolean isIncomplete() {
        return this.status.equals(Status.Type.Incomplete);
    }
    
    /**
     * Returns true if the status is complete
     */
    public boolean isComplete() {
        return this.status.equals(Status.Type.Complete);
    }
    
    /**
     * Returns true if the status is overdue
     */
    public boolean isOverdue() {
        return this.status.equals(Status.Type.Overdue);
    }

    @Override
    public String toString() {
        return status.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Status // instanceof handles nulls
                && this.status == ((Status) other).status); // state check
    }

}
```
###### /java/seedu/todolist/model/task/TaskTime.java
``` java
/**
 * Represents a Task's time in the to do list.
 * Guarantees: immutable; is valid as declared in {@link #isValidTime(String)}
 */
public class TaskTime implements Comparable<TaskTime> {
    
    public static final String MESSAGE_TIME_CONSTRAINTS = "Task time should be in 24-hr format or AM/PM format";
    public static final String MESSAGE_TIME_INVALID = "Task time provided is invalid!";

    //format: 24-hr
    public static final String TIME_VALIDATION_REGEX_2 = "(\\p{Digit}){1,2}:(\\p{Digit}){2}";
    //format: AM/PM
    public static final String TIME_VALIDATION_REGEX_1 = "(\\p{Digit}){1,2}(:(\\p{Digit}){2})?\\s?[AaPp][Mm]";
    public static final String TIME_VALIDATION_REGEX_FORMAT = TIME_VALIDATION_REGEX_1 + "|" + TIME_VALIDATION_REGEX_2;

    public static final String TIME_DISPLAY_FORMAT = "h:mma";

    private LocalTime time;
    
    public TaskTime() {
        
    }
    
    /**
     * Validates given time.
     *
     * @throws IllegalValueException if given date is invalid.
     */
    public TaskTime(String time) throws IllegalValueException {
        assert time != null;
        String trimmedTime = time.trim();
        if (!isValidTime(trimmedTime)) {
            throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
        }
        
        try {
            this.time = TimeParser.parseTime(trimmedTime);
        } catch (DateTimeException dateTimeException) {
            throw new IllegalValueException(MESSAGE_TIME_INVALID);
        }
    }
    
    /**
     * Returns true if a given string is a valid task time.
     */
    public static boolean isValidTime(String test) {
        return test.matches(TIME_VALIDATION_REGEX_FORMAT);
    }
    
    /**
     * Returns true if this time is earlier than given time.
     */
    public boolean isBefore(TaskTime other) {
        return this.time.isBefore(other.getTime());
    }

    public LocalTime getTime() {
        return this.time;
    }
    
    /**
     * Return the current time
     */
    public static TaskTime now() {
        TaskTime now = new TaskTime();
        now.time = LocalTime.now();
        return now;
    }
    
    @Override
    public String toString() {
        return time.format(DateTimeFormatter.ofPattern(TIME_DISPLAY_FORMAT));
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskTime // instanceof handles nulls
                && this.time.equals(((TaskTime) other).time)); // state check
    }
    
    /**
     * Returns true if both TaskTimes are equal.
     * Use this method when both TaskTimes could be null
     */
    public static boolean isEquals(TaskTime time, TaskTime other) {
        if (time == null && other == null) {
            //both are null, they are equal
            return true;
        }
        
        if (time != null) {
            return time.equals(other);
        } else {
            // if date is null, other cannot be null.
            // thus, they are not equal
            return false;
        }
    }
    
    @Override 
    public int compareTo(TaskTime time) {
        if (time == null) return -1;
        
        if (this.equals(time)) {
            return 0;
        } else if (this.isBefore(time)) {
            return -1;
        } else {
            return 1;
        }
    }
}
```
###### /java/seedu/todolist/model/task/UniqueTaskList.java
``` java
    /**
     * Marks the equivalent task(s) in the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean mark(ReadOnlyTask... toMark) throws TaskNotFoundException {
        assert toMark != null;
        boolean taskFound = false;
        for (ReadOnlyTask task : toMark) {
            taskFound = (internalList.indexOf(task) != -1);
            if (!taskFound) {
                throw new TaskNotFoundException();
            }
            Task taskMarked = new Task(task.getName(), task.getInterval(), task.getLocation(), task.getRemarks(), new Status(Status.Type.Complete));
            internalList.set(internalList.indexOf(task), taskMarked);
        }
        Collections.sort(internalList);
        return taskFound;
    }

```
###### /java/seedu/todolist/ui/TaskCard.java
``` java
    @FXML
    public void initialize() {
        id.setText(displayedIndex + ". ");
        name.setText(task.getName().fullName);
        formatIntervalField();
        formatLocationField();
        formatRemarksField();
    }
    
    /**
     * Display the fields accordingly based on the type of task.
     */
    private void formatIntervalField() {
        if (task.getInterval().isFloat()){
            intervalIcon.setVisible(false);
            startDate.setText(""); 
            endDate.setText("");  
        } else if (task.getInterval().isDeadlineWithTime()) {
            intervalIcon.setImage(AppUtil.getImage(ICON_ALARM_CLOCK));
            startDate.setManaged(false);
            endDate.setText(task.getInterval().formatEndDateTime());
        } else if (task.getInterval().isDeadlineWithoutTime()) {
            intervalIcon.setImage(AppUtil.getImage(ICON_ALARM_CLOCK));
            startDate.setManaged(false);
            endDate.setText(task.getInterval().formatEndDate());    
        } else {
            intervalIcon.setImage(AppUtil.getImage(ICON_HOURGLASS));
            startDate.setText(task.getInterval().formatStartDateTime()); 
            endDate.setText(task.getInterval().formatEndDateTime());   
        }
        
    }
    
    private void formatLocationField() {
        if (!Strings.isNullOrEmpty(task.getLocation().location)) {
            locationIcon.setVisible(true);
        }
        locationParam.setText(task.getLocation().toString());
    }
    
    private void formatRemarksField() {
        if (!Strings.isNullOrEmpty(task.getRemarks().remarks)) {
            remarksIcon.setVisible(true);
        }
        remarks.setText(task.getRemarks().toString());
    }
    
```
###### /resources/view/DarkTheme.css
``` css
.list-view {
    -fx-background-color: #cccccc;
    -fx-padding: 3;
}

.list-cell {
    -fx-background-color: #eeeeee;
    -fx-background-radius: 10;
    -fx-border-width: 2px;
    -fx-border-color: #cccccc;
    -fx-border-radius: 8;
}

.list-cell:empty {
    -fx-background-color: transparent;
}

.list-cell:filled:selected:focused, .list-cell:filled:selected {
    -fx-background-color: #dddddd;
}

.list-cell .label {
    -fx-text-fill: #111111;
}

```
###### /resources/view/DarkTheme.css
``` css
#cardPane {    
    -fx-background-color: transparent;
}

.tab {
    -fx-focus-color: transparent;
    -fx-background-color: transparent;
    -fx-opacity: 0.7;
    -fx-padding: 20 20 5 60;
}

.tab .tab-label { 
    -fx-alignment: CENTER;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: #bab6b6;
    -fx-font-size: 11pt;
}

.tab:selected {
    -fx-opacity: 1.0;
}

.tab:selected .tab-label { 
    -fx-alignment: CENTER;
    -fx-text-fill: #ffffff;
}

#notificationPane .title{
    -fx-background-color: transparent;
    -fx-padding: 25 20 10 60;
    -fx-background-image: url('../images/notification_title.png');
    -fx-background-repeat: no-repeat;
    -fx-background-size: 170;
}

#incompleteTab {
    -fx-background-image: url('../images/incomplete_tab_title.png');
    -fx-background-size: cover;
}

#completedTab {
    -fx-translate-x: -1;
    -fx-background-image: url('../images/completed_tab_title.png');
    -fx-background-size: cover;
}

#overdueTab {
    -fx-translate-x: -1;
    -fx-padding: 20 30 5 70;
    -fx-background-image: url('../images/overdue_tab_title.png');
    -fx-background-size: cover;
}

#taskListPanelPlaceholder {
    -fx-background-color: #ffc425;
    -fx-background-radius: 0 3 3 3;
}

#completeTaskListPanelPlaceholder {
    -fx-background-color: #00b159;
    -fx-background-radius: 0 3 3 3;
}

#overdueTaskListPanelPlaceholder {
    -fx-background-color: #d11141;
    -fx-background-radius: 0 3 3 3;
}

#commandPaneTitleLabel {
    -fx-background-image: url('../images/command_pane_title.png');
    -fx-background-repeat: no-repeat;
    -fx-background-size: 170;
    -fx-text-fill: #ffffff;
    -fx-padding: 25 30 10 70;
}

#resultDisplayPlaceholder, #commandBoxPlaceholder {
    -fx-background-color: #f37735;
    -fx-background-radius: 0 3 3 3;
}
```
###### /resources/view/MainWindow.fxml
``` fxml
        <SplitPane dividerPositions="0.7" orientation="VERTICAL">
            <items>
                <VBox>
                    <padding>
                        <Insets bottom="5.0" left="5.0" right="10.0" top="5.0" />
                    </padding>
                    <TabPane fx:id="allTasksTabPane" prefHeight="500.0" prefWidth="200.0" VBox.vgrow="ALWAYS">
                        <Tab fx:id="incompleteTab" closable="false" onSelectionChanged="#OnTabSelectionChanged" text="Incomplete">
                            <AnchorPane fx:id="taskListPanelPlaceholder" styleClass="pane">
                                <padding>
                                    <Insets bottom="3.0" left="3.0" right="3.0" top="3.0" />
                                </padding>
                            </AnchorPane>
                        </Tab>
                        <Tab fx:id="completedTab" closable="false" onSelectionChanged="#OnTabSelectionChanged" text="Completed">
                            <AnchorPane fx:id="completeTaskListPanelPlaceholder">
                                <padding>
                                    <Insets bottom="3.0" left="3.0" right="3.0" top="3.0" />
                                </padding>
                            </AnchorPane>
                        </Tab>
                        <Tab fx:id="overdueTab" closable="false" onSelectionChanged="#OnTabSelectionChanged" text="Overdue">
                            <AnchorPane fx:id="overdueTaskListPanelPlaceholder">
                                <padding>
                                    <Insets bottom="3.0" left="3.0" right="3.0" top="3.0" />
                                </padding>
                            </AnchorPane>
                           </Tab>
                    </TabPane>
                </VBox>
                <VBox>
                    <padding>
                        <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
                    </padding>
                    <children>
                        <Label fx:id="commandPaneTitleLabel" text="Command" textAlignment="CENTER"/>
                        <AnchorPane fx:id="resultDisplayPlaceholder" styleClass="anchor-pane" VBox.vgrow="ALWAYS">
                            <padding>
                                <Insets bottom="1.0" left="3.0" right="3.0" top="3.0" />
                            </padding>
                        </AnchorPane>
                        <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane">
                            <padding>
                                <Insets bottom="3.0" left="3.0" right="3.0" top="1.0" />
                            </padding>
                        </AnchorPane>
                    </children>
                </VBox>
             </items>
          </SplitPane>
```
###### /resources/view/TaskListCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="NEVER" maxWidth="50.0" minWidth="50.0" prefWidth="50.0" />
                <ColumnConstraints hgrow="ALWAYS" minWidth="150.0" prefWidth="150.0" />
                <ColumnConstraints halignment="LEFT" hgrow="NEVER" maxWidth="200.0" minWidth="200.0" prefWidth="200.0" />
             </columnConstraints>
             <rowConstraints>
                <RowConstraints minHeight="10.0" valignment="TOP" />
             </rowConstraints>
            <children>
            <Label fx:id="id" alignment="TOP_CENTER" contentDisplay="RIGHT" styleClass="cell_big_label" text="id" />
            <HBox alignment="CENTER_LEFT" GridPane.columnIndex="2" GridPane.hgrow="ALWAYS">
                <children>
                    <ImageView fx:id="intervalIcon" fitHeight="60.0" fitWidth="60.0" pickOnBounds="true" preserveRatio="true">
                        <image>
                            <Image url="@../images/clock_icon.png" />
                        </image>
                    </ImageView>
                    <VBox alignment="CENTER_LEFT">
                        <children>
                            <Label fx:id="startDate" styleClass="cell_small_label" text="\$start">
                                <padding>
                                    <Insets left="5.0" />
                                </padding>
                            </Label>
                            <Label fx:id="endDate" styleClass="cell_small_label" text="\$end">
                                <padding>
                                    <Insets left="5.0" />
                                </padding>
                            </Label>
                        </children>
                        <HBox.margin>
                            <Insets left="-10.0" />
                        </HBox.margin>
                    </VBox>
                </children>
            </HBox>
            <VBox GridPane.columnIndex="1">
                <children>
                    <Label fx:id="name" styleClass="cell_big_label" text="\$first" />
                    <HBox alignment="CENTER_LEFT">
                           <children>
                            <ImageView fx:id="locationIcon" fitHeight="15.0" fitWidth="15.0" pickOnBounds="true" preserveRatio="true" visible="false">
                                <image>
                                    <Image url="@../images/location_icon.png" />
                                </image>
                            </ImageView>
                            <Label fx:id="locationParam" styleClass="cell_small_label" text="\$location">
                                <padding>
                                    <Insets left="5.0" />
                                </padding>
                            </Label>
                        </children>
                        <padding>
                            <Insets top="10.0" />
                        </padding>
                    </HBox>
                    <HBox alignment="CENTER_LEFT">
                        <children>
                            <ImageView fx:id="remarksIcon" fitHeight="15.0" fitWidth="15.0" pickOnBounds="true" preserveRatio="true" visible="false">
                                <image>
                                    <Image url="@../images/remarks_icon.png" />
                                   </image>
                            </ImageView>
                            <Label fx:id="remarks" styleClass="cell_small_label" text="\$remarks">
                                <padding>
                                    <Insets left="5.0" />
                                   </padding>
                            </Label>
                        </children>
                        <padding>
                            <Insets top="2.0" />
                           </padding>
                      </HBox>
                </children>
            </VBox>
            </children>
            <padding>
                <Insets bottom="5.0" left="20.0" right="10.0" top="5.0" />
            </padding>
        </GridPane>
    </children>
</HBox>
```
