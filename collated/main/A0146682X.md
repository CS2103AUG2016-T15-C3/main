# A0146682X
###### /java/seedu/todolist/logic/commands/EditCommand.java
``` java
/**
 * Edits the information of an existing task.
 */

public class EditCommand extends Command {

	public static final String COMMAND_WORD = "edit";

	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits a task in the list displayed. "
			+ "Parameters: [index] NAME [from DATETIME] [to DATETIME] [at LOCATION] [remarks REMARKS] \n"
			+ "Example: " + COMMAND_WORD
			+ " 1 dinner with mom from 13 oct 2016 7pm to 13 oct 2016 8pm at home remarks buy fruits";

	public static final String MESSAGE_SUCCESS = "Task edited: %1$s";

	private final int targetIndex;

	private String name;
	private String startDate;
	private String startTime;
	private String endDate;
	private String endTime;
	private String location;
	private String remarks;

	public EditCommand(int targetIndex, String name, String startDate, String startTime, String endDate, String endTime,
			String location, String remarks) throws IllegalValueException {
		this.targetIndex = targetIndex;

		this.name = name;
		this.startDate = startDate;
		this.startTime = startTime;
		this.endDate = endDate;
		this.endTime = endTime;
		this.location = location;
		this.remarks = remarks;
	}

	@Override
	public CommandResult execute() {
		
		UnmodifiableObservableList<ReadOnlyTask> lastShownList = null;
        
        if (model.getCurrentTab().equals(MainWindow.TAB_TASK_COMPLETE)) {
            lastShownList = model.getFilteredCompleteTaskList();
        }
        else {
            lastShownList = model.getFilteredIncompleteTaskList();
        }
        
		if (lastShownList.size() < targetIndex) {
			indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
		}

		ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);

		if(name==null) name = taskToEdit.getName().toString();

		Interval originalInterval = taskToEdit.getInterval();

		if (originalInterval != null) {
			TaskDate originalStartDate = originalInterval.getStartDate();
			if(originalStartDate!=null && startDate==null) startDate = originalStartDate.toString();
			TaskTime originalStartTime = originalInterval.getStartTime();
			if(originalStartTime!=null && startTime==null) startTime = originalStartTime.toString();
			TaskDate originalEndDate = originalInterval.getEndDate();
			if(originalEndDate!=null && endDate==null) endDate = originalEndDate.toString();
			TaskTime originalEndTime = originalInterval.getEndTime();
			if(originalEndTime!=null && endTime==null) endTime = originalEndTime.toString();
		}

		Location originalLocation = taskToEdit.getLocation();
		if(originalLocation != null && location==null) location = originalLocation.toString();

		Remarks originalRemarks = taskToEdit.getRemarks();
		if(originalRemarks != null && remarks==null) remarks = originalRemarks.toString();

		Status originalStatus = taskToEdit.getStatus();

		Task replacement;
		try {
			replacement = new Task(
					new Name(name),
					new Interval(startDate, startTime, endDate, endTime),
					new Location(location),
					new Remarks(remarks),
					new Status(originalStatus.toString())
					);
		} catch (IllegalValueException ive) {
			return new CommandResult(String.format(ive.getMessage()));
		}

		try {
			model.editTask(taskToEdit, replacement);
		} catch (TaskNotFoundException pnfe) {
			assert false : "The target task cannot be missing";
		}

		return new CommandResult(String.format(MESSAGE_SUCCESS, replacement));
	}
}
```
###### /java/seedu/todolist/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the edit task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareEdit(String args) {
    	
    	Matcher index_matcher = Pattern.compile("\\d+").matcher(args);
    	index_matcher.find();
    	
    	int index;
    	
    	try {
    		index = Integer.valueOf(index_matcher.group());
    	} catch (IllegalStateException e) {
    		return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
    	}

    	String[] content = args.split("\\d+", 2);

        final Matcher matcher = TASK_DATA_ARGS_FORMAT.matcher(content[1]);
 
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        String name = matcher.group("name");
        String[] interval = parseInterval(matcher.group("interval"));
        String location = matcher.group("location");
        String remarks = matcher.group("remarks");

        try {
			return new EditCommand(index, name, interval[0], interval[1], interval[2], interval[3], location, remarks);
		} catch (IllegalValueException ive) {
			return new IncorrectCommand(ive.getMessage());
		}
    }
    
    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {

        int[] indexes;
        try {
             indexes = parseIndex(args);
        }
        catch (IllegalValueException ive) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }
        return new DeleteCommand(indexes);
    }

```
###### /java/seedu/todolist/model/ModelManager.java
``` java
    public synchronized void editTask(ReadOnlyTask target, Task replacement) throws TaskNotFoundException {
    	ToDoList previousToDoList = new ToDoList(this.ToDoList);
    	ToDoList.editTask(target, replacement);
    	ToDoListHistory.push(previousToDoList);
        indicateToDoListChanged();
    }
    //@author

    //=========== Filtered Task List Accessors ===============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredAllTaskList() {
        return new UnmodifiableObservableList<>(filteredAllTasks);
    }
    
```
###### /java/seedu/todolist/model/task/UniqueTaskList.java
``` java
    /**
     * Edits the equivalent task in the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean edit(ReadOnlyTask toEdit, Task replacement) throws TaskNotFoundException {
        assert toEdit != null;
        final boolean taskFound = (internalList.indexOf(toEdit) != -1);
        internalList.set(internalList.indexOf(toEdit), replacement);
        if (!taskFound) {
            throw new TaskNotFoundException();
        }
        return taskFound;
    }

    public ObservableList<Task> getInternalList() {
        return internalList;
    }
    
    public FilteredList<Task> getFilteredTaskList(String filter) {
        return internalList.filtered(p -> p.getStatus().toString().equals(filter));
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueTaskList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }
}
```
###### /java/seedu/todolist/model/ToDoList.java
``` java
    /**
     * Edits a task in the to-do list
     */
    public boolean editTask(ReadOnlyTask key, Task replacement) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.edit(key, replacement)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }
    //@author
    
    public boolean markTask(ReadOnlyTask... keys) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.mark(keys)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }

    public boolean removeTask(ReadOnlyTask... keys) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.remove(keys)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }

//// util methods

    @Override
    public String toString() {
        return tasks.getInternalList().size() + " tasks, " + tags.getInternalList().size() +  " tags";
        // TODO: refine later
    }

    @Override
    public List<ReadOnlyTask> getTaskList() {
        return Collections.unmodifiableList(tasks.getInternalList());
    }

    @Override
    public List<Tag> getTagList() {
        return Collections.unmodifiableList(tags.getInternalList());
    }

    @Override
    public UniqueTaskList getUniqueTaskList() {
        return this.tasks;
    }

    @Override
    public UniqueTagList getUniqueTagList() {
        return this.tags;
    }


    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ToDoList // instanceof handles nulls
                && this.tasks.equals(((ToDoList) other).tasks)
                && this.tags.equals(((ToDoList) other).tags));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasks, tags);
    }
}
```
